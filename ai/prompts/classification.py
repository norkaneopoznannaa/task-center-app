"""Промпты для классификации задач через Claude API"""
from typing import Optional


CLASSIFICATION_SYSTEM_PROMPT = """Ты - AI-ассистент для системного аналитика проекта РЭМД (Российская электронная медицинская документация).

Твоя задача: анализировать задачи и классифицировать их по типу, сложности и приоритету.

## Контекст проекта РЭМД:
- Проект связан с электронным документооборотом в медицине
- Ключевые системы:
  * ФЛК (формально-логический контроль) - валидация данных
  * СЭМД (структурированные электронные медицинские документы)
  * ГИСЗ/ЕГИСЗ (государственная информационная система здравоохранения)
  * МИС (медицинская информационная система)
- Высокая критичность из-за связи с медицинскими данными
- Регуляторные требования и стандарты (ISO, ГОСТ)
- Работа с персональными данными (СНИЛС, ОМС)

## Типы задач:
1. **Анализ/Исследование** - изучение требований, исследование проблем, анализ данных, паттернов
2. **Документация** - создание/обновление документов, спецификаций, инструкций, регламентов
3. **Разработка** - написание кода, создание решений, доработка функционала, технические задачи
4. **Координация** - организация встреч, согласования, коммуникация между командами, подготовка демо
5. **Баг/Проблема** - исправление ошибок, решение инцидентов, проверка изменений

## Уровни сложности:
- **низкая**: простые рутинные задачи, до 2 часов (обновить документ, проверить данные)
- **средняя**: требует анализа/исследования, 2-8 часов (анализ требований, исследование паттернов)
- **высокая**: комплексные задачи, требует координации, более 8 часов (разработка функционала, интеграция систем)

## Приоритеты (1-5):
- **5 (CRITICAL)**: блокирующие баги в продакшене, дедлайны сегодня/завтра, влияние на критичные системы
- **4 (HIGH)**: важные задачи с дедлайном на неделе, ключевые фичи, задачи от руководства
- **3 (MEDIUM)**: обычные задачи, дедлайн в течение месяца, плановые работы
- **2 (LOW)**: улучшения, оптимизации, некритичные задачи
- **1 (BACKLOG)**: идеи для будущего, исследования без дедлайна

## Факторы повышения приоритета:
- Упоминание "срочно", "блокер", "критично", "asap", "сегодня"
- Связь с продакшеном или критичными системами (ФЛК, СЭМД)
- Упоминание руководителей или заказчиков
- Задачи связанные с проверкой/валидацией данных
- Интеграции с ГИСЗ/ЕГИСЗ
- Баги с персональными данными

## Ключевые термины:
- ФЛК - валидация данных, критично
- СЭМД - основной формат документов
- ГИСЗ/ЕГИСЗ - государственная система, высокая важность
- МИС - медицинские информационные системы
- СНИЛС, ОМС - персональные данные, требуют особого внимания
- Витрина данных - отчетность и аналитика
- Лаунчер - точка входа в систему

Анализируй задачи внимательно и объективно. Возвращай результат в формате JSON.
"""


CLASSIFICATION_USER_PROMPT_TEMPLATE = """Проанализируй следующую задачу:

Название: {title}
Описание: {description}

{context}

Верни JSON со следующими полями:
{{
  "task_type": "один из: Анализ/Исследование, Документация, Разработка, Координация, Баг/Проблема",
  "complexity": "один из: низкая, средняя, высокая",
  "priority": число от 1 до 5,
  "confidence": число от 0.0 до 1.0 (уверенность в классификации),
  "reasoning": "краткое объяснение выбора (1-2 предложения)",
  "extracted_info": {{
    "estimated_hours": оценка времени в часах или null,
    "key_terms": ["список найденных ключевых терминов/аббревиатур из РЭМД"],
    "urgency_keywords": ["найденные слова срочности если есть"],
    "related_systems": ["связанные системы: ФЛК, СЭМД, ГИСЗ, МИС, etc"]
  }}
}}
"""


def get_classification_prompts(
    title: str,
    description: str,
    context: Optional[str] = None
) -> tuple[str, str]:
    """
    Генерация промптов для классификации задачи

    Args:
        title: Название задачи
        description: Описание задачи
        context: Дополнительный контекст (например, из документации)

    Returns:
        Кортеж (system_prompt, user_prompt)
    """
    system = CLASSIFICATION_SYSTEM_PROMPT

    # Добавление контекста в системный промпт если есть
    if context:
        system += f"\n\n## Дополнительный контекст из документации РЭМД:\n{context}"

    # Формирование контекста для user промпта
    context_text = ""
    if context:
        context_text = f"\nКонтекст из документации:\n{context}\n"

    user = CLASSIFICATION_USER_PROMPT_TEMPLATE.format(
        title=title,
        description=description,
        context=context_text
    )

    return system, user


# Промпт для пакетной классификации
BATCH_CLASSIFICATION_SYSTEM_PROMPT = CLASSIFICATION_SYSTEM_PROMPT


def get_batch_classification_prompt(tasks: list[dict]) -> str:
    """
    Генерация промпта для пакетной классификации

    Args:
        tasks: Список задач [{"title": ..., "description": ...}, ...]

    Returns:
        User prompt для пакетной обработки
    """
    tasks_text = "\n\n".join([
        f"ЗАДАЧА {i+1}:\nНазвание: {task['title']}\nОписание: {task.get('description', task['title'])}"
        for i, task in enumerate(tasks)
    ])

    prompt = f"""Проанализируй следующие задачи и верни JSON массив с результатами классификации для каждой:

{tasks_text}

Верни JSON массив в формате:
[
  {{
    "task_index": 1,
    "task_type": "один из: Анализ/Исследование, Документация, Разработка, Координация, Баг/Проблема",
    "complexity": "один из: низкая, средняя, высокая",
    "priority": число от 1 до 5,
    "confidence": число от 0.0 до 1.0,
    "reasoning": "краткое объяснение",
    "extracted_info": {{
      "estimated_hours": число или null,
      "key_terms": ["термины"],
      "urgency_keywords": ["слова срочности"],
      "related_systems": ["системы"]
    }}
  }},
  ...
]

ВАЖНО: верни ровно {len(tasks)} элементов в массиве, по одному для каждой задачи.
"""

    return prompt
